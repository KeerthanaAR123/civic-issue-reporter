import { Component, OnInit, AfterViewInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { IssueService } from '../../../core/services/issue.service';
import * as L from 'leaflet';

@Component({
  selector: 'app-report-issue',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './report-issue.component.html',
  styleUrl: './report-issue.component.css'
})
export class ReportIssueComponent implements OnInit, AfterViewInit {
  private fb = inject(FormBuilder);
  private issueService = inject(IssueService);
  private router = inject(Router);
  private http = inject(HttpClient);

  reportForm: FormGroup = this.fb.group({
    title: ['', Validators.required],
    category: ['', Validators.required],
    address: ['', Validators.required],
    description: ['', Validators.required],
    image: [null]
  });

  selectedFile: File | null = null;
  isSubmitting = false;
  
  private map: any;
  private marker: any;

  ngOnInit() {}

  ngAfterViewInit(): void {
    this.initMap();
  }

  private initMap(): void {
    // 1. Initialize Map
    this.map = L.map('map').setView([20.5937, 78.9629], 5);

    // 2. Use CartoDB Voyager tiles (Looks cleaner, more like Google Maps)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href=\'https://www.openstreetmap.org/copyright\'>OSM</a> contributors &copy; <a href=\'https://carto.com/attributions\'>CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }).addTo(this.map);

    // 3. Define Google-Style Red Icon
    const googleRedIcon = new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // 4. Locate User immediately
    this.locateUser(googleRedIcon);
  }

  // Changed to PUBLIC so button can call it
  locateUser(customIcon?: any): void {
    // Use the custom red icon if passed, otherwise recreate it
    const icon = customIcon || new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          
          this.map.setView([lat, lng], 16);
          this.addMarker(lat, lng, icon);
          this.getAddress(lat, lng);
        },
        (error) => {
          console.error('Geolocation error:', error);
          alert('Could not get location. Error: ' + error.message + '. Please drag the pin manually or enter address.');
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    } else {
      alert('Geolocation is not supported by this browser. Please enter address manually.');
    }
  }

  private addMarker(lat: number, lng: number, icon: any): void {
    if (this.marker) this.map.removeLayer(this.marker);
    
    this.marker = L.marker([lat, lng], { draggable: true, icon: icon }).addTo(this.map);
    
    this.marker.on('dragend', () => {
      const pos = this.marker.getLatLng();
      this.getAddress(pos.lat, pos.lng);
    });
  }

  private getAddress(lat: number, lng: number): void {
    const url = 'https://nominatim.openstreetmap.org/reverse?format=json&lat=' + lat + '&lon=' + lng;
    this.http.get(url).subscribe((data: any) => {
      if (data && data.display_name) {
        this.reportForm.patchValue({ address: data.display_name });
      }
    });
  }

  onFileSelected(event: any) {
    this.selectedFile = event.target.files[0];
  }

  onSubmit() {
    if (this.reportForm.invalid) {
      alert('Please fill all required fields');
      return;
    }
    this.isSubmitting = true;
    const formData = new FormData();
    Object.keys(this.reportForm.controls).forEach(key => {
      formData.append(key, this.reportForm.get(key)?.value);
    });
    if (this.selectedFile) formData.append('image', this.selectedFile);

    this.issueService.createIssue(formData).subscribe({
      next: () => {
        alert('Report Submitted Successfully!');
        this.router.navigate(['/dashboard']);
      },
      error: (err) => {
        this.isSubmitting = false;
        console.error('Submission error:', err);
        alert('Failed to submit report: ' + (err.error?.message || err.message || 'Unknown error'));
      }
    });
  }
}
